{"id":"f5b12212-a4f7-4ea0-9c8c-7c396ff1b56d","zed":"context","version":"0.4.0","text":"\n\n```rs stocksim-backend/src/main.rs\nmod auth;\nmod data;\nmod db;\nmod handlers;\nmod models;\n\nuse crate::data::finnhub;\nuse crate::data::yfinance;\nuse crate::db::DatabasePool;\nuse crate::handlers::{accounts, portfolio, trading};\nuse crate::models::{AppState, Performance};\nuse axum::http::header::{\n    ACCESS_CONTROL_ALLOW_CREDENTIALS, ACCESS_CONTROL_ALLOW_ORIGIN, CONTENT_TYPE, COOKIE,\n};\nuse axum::http::HeaderValue;\nuse axum::{\n    routing::{delete, get, post},\n    Router,\n};\nuse reqwest::Method;\nuse rusqlite::Connection;\nuse std::sync::Arc;\nuse time::Duration;\nuse tower_http::cors::CorsLayer;\nuse tower_http::trace::{self, TraceLayer};\nuse tower_sessions::{ExpiredDeletion, Expiry, SessionManagerLayer};\nuse tower_sessions_rusqlite_store::RusqliteStore;\nuse tracing::Level;\n\n/// Main method. Initializes the server and runs the application.\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Set the log level based on the command line argument\n    let args: Vec<String> = std::env::args().collect();\n    let mut log_level = Level::INFO;\n    if args.len() >= 2 {\n        log_level = match args[1].as_str() {\n            \"debug\" => Level::DEBUG,\n            \"warn\" => Level::WARN,\n            \"error\" => Level::ERROR,\n            _ => Level::INFO,\n        };\n    }\n\n    // TODO: store sessions in MongoDB instead of a SQLite file\n    let db_path = \".\";\n\n    // Initialize our session store as a SQLite database\n    let conn = Connection::open(format!(\"{}{}\", db_path, \"/sessions.db\")).unwrap();\n    let session_store = RusqliteStore::new(conn.into());\n    session_store.migrate().await?;\n\n    // Start a task to delete expired sessions every 5 seconds\n    let deletion_task = tokio::task::spawn(\n        session_store\n            .clone()\n            .continuously_delete_expired(tokio::time::Duration::from_secs(5)),\n    );\n\n    // Create session layer with some configuration\n    let session_layer = SessionManagerLayer::new(session_store)\n        .with_secure(false)\n        .with_expiry(Expiry::OnInactivity(Duration::days(7)))\n        .with_same_site(tower_sessions::cookie::SameSite::Lax)\n        .with_http_only(true)\n        .with_path(\"/\");\n\n    // Initalize dotenv so we can read .env file\n    dotenv::dotenv().ok();\n\n    // Frontend URL for CORS\n    let origin =\n        dotenv::var(\"FRONTEND_URL\").unwrap_or_else(|_| \"http://localhost:5173\".to_string());\n\n    // Initialize CORS layer\n    let cors = CorsLayer::new()\n        .allow_credentials(true) // For session cookies\n        .allow_origin(origin.parse::<HeaderValue>().unwrap())\n        .allow_methods(vec![Method::DELETE, Method::GET, Method::POST])\n        .allow_headers(vec![\n            ACCESS_CONTROL_ALLOW_CREDENTIALS,\n            ACCESS_CONTROL_ALLOW_ORIGIN,\n            CONTENT_TYPE,\n            COOKIE,\n        ]);\n\n    // Initialize tracing\n    tracing_subscriber::fmt()\n        .with_target(false)\n        .compact()\n        .with_max_level(log_level)\n        .init();\n\n    tracing::info!(\"Max log level set to {}\", log_level);\n\n    // Initialize database pool with MongoDB\n    let mongo_connection_uri = dotenv::var(\"MONGO_URI\").expect(\"MONGO_URI must be set\");\n    let pool = DatabasePool::new(&mongo_connection_uri.to_string())\n        .await\n        .unwrap();\n\n    let shared_state = Arc::new(AppState::new(pool));\n\n    // This async task updates the account and portfolio every 60 seconds.\n    // The task checks if the market is open and if it is, it will update the account value and\n    // portfolio values using run_updates.\n    tokio::task::spawn({\n        let pool = shared_state.pool.clone();\n        async move {\n            let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(60));\n            loop {\n                interval.tick().await;\n\n                if !trading::is_market_open().await {\n                    tracing::info!(\"Market is closed, skipping update\");\n                    continue;\n                }\n                let accounts = pool.get_all_accounts().await.unwrap_or_else(|e| {\n                    tracing::error!(\"Failed to fetch accounts: {}\", e);\n                    vec![]\n                });\n\n                for account in accounts {\n                    let email = account.id.clone();\n                    let game_id = account.game_id.clone();\n                    if let Err(e) = run_updates(pool.clone(), &email, &game_id).await {\n                        tracing::error!(\"Failed to update account: {}\", e);\n                    } else {\n                        tracing::info!(\"Updated account: {} - {}\", email, game_id);\n                    }\n                }\n            }\n        }\n    });\n\n    // This async task will execute pending trades every 10 seconds.\n    // If market is open, the task will go through all pending trades and execute them, if they are\n    // still valid. If a trade is invalid (i.e., not enough cash to buy), the trade will be removed\n    // from the pending trades and not executed.\n    tokio::task::spawn({\n        let pool = shared_state.pool.clone();\n        let pending_cache = shared_state.pending_cache.clone();\n        let account_cache = shared_state.account_cache.clone();\n        let portfolio_cache = shared_state.portfolio_cache.clone();\n        let history_cache = shared_state.history_cache.clone();\n\n        async move {\n            let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(10));\n            loop {\n                interval.tick().await;\n\n                if !trading::is_market_open().await {\n                    // No trades can be executed if the market is closed\n                    tracing::info!(\"Market is closed, not executing pending trades\");\n                    continue;\n                }\n\n                // Get pending trades from DB\n                let pending = pool.get_pending_trades().await.unwrap();\n\n                for items in pending {\n                    let trades = items.trades;\n                    let account = items.account_id;\n                    let game = items.game_id;\n\n                    let key = (account.clone(), game.clone());\n\n                    // Loop through all pending trades to execute.\n                    'trades: for trade in trades {\n                        let action = trade.action.as_str();\n                        let stock_symbol = trade.stock_symbol;\n                        let quantity = trade.quantity;\n                        let quote = match yfinance::get_quote(stock_symbol.to_string()).await {\n                            Ok(quote) => quote,\n                            Err(_) => {\n                                tracing::error!(\"Failed to fetch stock price\");\n                                continue 'trades; // skip to the next trade if failed\n                            }\n                        };\n\n                        let cash = pool\n                            .get_account_with_game(&account, &game)\n                            .await\n                            .unwrap_or_default()\n                            .unwrap_or_default()\n                            .cash;\n\n                        let price = quote.regular_market_price;\n                        let total_cost = match price.checked_mul(quantity) {\n                            Some(cost) => cost,\n                            None => {\n                                tracing::error!(\"Quantity too large. Please reduce the amount of shares being traded.\");\n                                pool.remove_pending_trade(&account, &game, &trade.id)\n                                    .await\n                                    .unwrap();\n\n                                pending_cache.invalidate(&key).await;\n\n                                continue 'trades; // skip to the next trade\n                            }\n                        };\n\n                        if cash < total_cost {\n                            tracing::error!(\n                                \"Not enough cash to buy {} shares of {}\",\n                                quantity,\n                                stock_symbol\n                            );\n\n                            pool.remove_pending_trade(&account, &game, &trade.id)\n                                .await\n                                .unwrap();\n\n                            pending_cache.invalidate(&key).await;\n\n                            continue 'trades; // skip to the next trade\n                        }\n\n                        let trade_id = trade.id.clone();\n\n                        match action {\n                            \"BUY\" => {\n                                let mut logo = String::from(&stock_symbol);\n                                let mut category = String::from(\"\");\n                                if quote.instrument_type == \"EQUITY\" {\n                                    let stock_profile = match finnhub::fetch_stock_profile(\n                                        &stock_symbol.to_string(),\n                                    )\n                                    .await\n                                    {\n                                        Ok(stock) => stock,\n                                        Err(e) => {\n                                            tracing::error!(\"Error fetching stock profile: {}\", e);\n                                            continue 'trades; // skip to the next trade\n                                        }\n                                    };\n                                    logo = stock_profile.logo.clone();\n                                    category = stock_profile.category.clone();\n                                }\n\n                                let mut session = pool.client.start_session().await.unwrap();\n\n                                if let Err(e) = session.start_transaction().await {\n                                    tracing::error!(\"Failed to start transaction: {}\", e);\n                                    continue 'trades;\n                                }\n\n                                let result = async {\n                                    let mut account = pool\n                                        .get_account_with_game(&account, &game)\n                                        .await\n                                        .unwrap()\n                                        .unwrap();\n                                    if account.cash < total_cost {\n                                        return Err(format!(\n                                            \"Not enough cash to buy {} shares of {}\",\n                                            quantity, stock_symbol\n                                        ));\n                                    }\n\n                                    account.cash -= total_cost;\n                                    if let Err(e) = pool\n                                        .update_account(\n                                            &account.id,\n                                            &game,\n                                            account.value as i64,\n                                            account.cash as i64,\n                                            account.change as i64,\n                                        )\n                                        .await\n                                    {\n                                        tracing::error!(\"Failed to update account: {}\", e);\n                                        return Err(format!(\"Failed to update account: {}\", e));\n                                    }\n\n                                    let holding = pool\n                                        .get_holding(&account.id, &game, &stock_symbol)\n                                        .await\n                                        .unwrap();\n                                    let holding = holding.unwrap_or_default();\n\n                                    if holding.quantity > 0 {\n                                        // stock already owned!\n                                        let new_quantity = match holding.quantity.checked_add(quantity) {\n                                            Some(quantity) => quantity,\n                                            None => { return Err(String::from(\"Quantity too large. Please reduce the amount of shares being traded.\"));\n                                            }\n                                        };\n\n\n                                        let new_price = (((holding.purchase_price as f64 * holding.quantity as f64)\n                                                        + (price as f64 * quantity as f64))\n                                                        / new_quantity as f64) as i32;\n                                        if let Err(e) =  pool.update_holding(\n                                            &account.id,\n                                            &game,\n                                            &stock_symbol,\n                                            new_quantity as i64,\n                                            new_price as i64,\n                                        )\n                                        .await {\n                                            tracing::error!(\"Failed to update holding: {}\", e);\n                                            return Err(format!(\"Failed to update holding: {}\", e));\n                                        }\n                                    } else {\n\n                                    let dp = quote.day_change_percent as f64 / quote.previous_close as f64;\n                                    pool.add_holding(models::Holding {\n                                                        account_id: account.id.clone(),\n                                                        game_id: game.clone(),\n                                                        stock_symbol: stock_symbol.clone(),\n                                                        stock_name: quote.long_name.clone(),\n                                                        quantity,\n                                                        purchase_price: price,\n                                                        total_value: price*quantity,\n                                                        current_price: price,\n                                                        category,\n                                                        day_change: quote.day_change,\n                                                        day_change_percent: (dp * 100.0) as i32,\n                                                        stock_logo_url: logo,\n                                                        overall_change: 0,\n                                                   })\n                                                    .await\n                                                    .unwrap();\n                                    }\n\n                                    pool.remove_pending_trade(&account.id, &game, &trade_id).await.unwrap();\n\n                                    pool.add_transaction(crate::models::Transaction {\n                                        id: uuid::Uuid::new_v4().to_string(),\n                                        account_id: account.id.clone(),\n                                        game_id: game.clone(),\n                                        transaction_type: String::from(\"BUY\"),\n                                        stock_symbol: stock_symbol.clone(),\n                                        quantity,\n                                        price,\n                                        timestamp: chrono::Local::now().to_rfc3339(),\n                                    })\n                                    .await\n                                    .unwrap();\n\n                                    Ok(())\n                                }\n                                .await;\n\n                                match result {\n                                    Ok(_) => {\n                                        pending_cache.invalidate(&key).await;\n                                        account_cache.invalidate(&key).await;\n                                        portfolio_cache.invalidate(&key).await;\n                                        history_cache.invalidate(&key).await;\n\n                                        session.commit_transaction().await.unwrap()\n                                    }\n                                    Err(e) => {\n                                        tracing::error!(\"Failed to commit transaction: {}\", e);\n                                        session.abort_transaction().await.unwrap();\n                                        continue 'trades;\n                                    }\n                                };\n                            }\n                            \"SELL\" => {\n                                // Start a MongoDB transaction for atomicity.\n                                let mut session = pool.client.start_session().await.unwrap();\n                                session.start_transaction().await.unwrap();\n                                let result = async {\n                                    let mut account = pool\n                                        .get_account_with_game(&account, &game)\n                                        .await\n                                        .unwrap()\n                                        .unwrap();\n                                    let current_quantity = pool\n                                        .get_holding(&account.id, &game, &stock_symbol)\n                                        .await\n                                        .unwrap()\n                                        .unwrap_or_default()\n                                        .quantity;\n                                    if current_quantity == 0 {\n                                        return Err(String::from(\n                                            \"You cannot sell a stock you don't own.\",\n                                        ));\n                                    }\n                                    if current_quantity < quantity {\n                                        return Err(String::from(\n                                            \"You cannot sell more shares than you own.\",\n                                        ));\n                                    }\n                                    account.cash += total_cost;\n                                    pool.update_account(\n                                        &account.id,\n                                        &game,\n                                        account.value as i64,\n                                        account.cash as i64,\n                                        account.change as i64,\n                                    )\n                                    .await\n                                    .unwrap();\n                                    let new_quantity = current_quantity - quantity;\n\n                                    if new_quantity == 0 {\n                                        pool.delete_holding(&account.id, &game, &stock_symbol)\n                                            .await\n                                            .unwrap();\n                                    } else {\n                                        let holding = pool\n                                            .get_holding(&account.id, &game, &stock_symbol)\n                                            .await\n                                            .unwrap()\n                                            .unwrap();\n                                        pool.update_holding(\n                                            &account.id,\n                                            &game,\n                                            &stock_symbol,\n                                            new_quantity as i64,\n                                            holding.purchase_price as i64,\n                                        )\n                                        .await\n                                        .unwrap();\n                                    }\n\n                                    // After execution, delete the pending trade. It isn't pending anymore.\n                                    pool.remove_pending_trade(&account.id, &game, &trade_id)\n                                        .await\n                                        .unwrap();\n\n                                    // Add transaction to the database\n                                    pool.add_transaction(crate::models::Transaction {\n                                        id: uuid::Uuid::new_v4().to_string(),\n                                        account_id: account.id.clone(),\n                                        game_id: game.clone(),\n                                        transaction_type: String::from(\"SELL\"),\n                                        stock_symbol: stock_symbol.clone(),\n                                        quantity,\n                                        price,\n                                        timestamp: chrono::Local::now().to_rfc3339(),\n                                    })\n                                    .await\n                                    .unwrap();\n\n                                    Ok(())\n                                }\n                                .await;\n\n                                // Commit or abort the transaction based on the result.\n                                match result {\n                                    Ok(_) => {\n                                        pending_cache.invalidate(&key).await;\n                                        account_cache.invalidate(&key).await;\n                                        portfolio_cache.invalidate(&key).await;\n                                        history_cache.invalidate(&key).await;\n\n                                        session.commit_transaction().await.unwrap()\n                                    }\n                                    Err(e) => {\n                                        tracing::error!(\"Failed to commit transaction: {}\", e);\n                                        session.abort_transaction().await.unwrap();\n                                        continue 'trades;\n                                    }\n                                };\n                            }\n                            // well, well, well ... this should never happen!\n                            // Trade actions should only every be BUY or SELL.\n                            // This means that our pending trade had an invalid action.\n                            _ => {\n                                tracing::error!(\"invalid trade action: {}\", action)\n                            }\n                        };\n                    }\n                }\n            }\n        }\n    });\n\n    // This async task updates the day performance of all accounts.\n    // It starts running at 00:00 UTC and updates performances for all accounts. It will do so\n    // every 24 hours (at 00:00 UTC daily).\n    tokio::task::spawn({\n        let pool = shared_state.pool.clone();\n        let performance_cache = shared_state.performance_cache.clone();\n        async move {\n            // We wait until midnight to start the loop.\n            // It is midnight UTC time, which is 7PM EST.\n            let now = chrono::Local::now();\n            let start = now\n                .date_naive()\n                .succ_opt()\n                .unwrap()\n                .and_hms_opt(21, 30, 0) // midnight UTC\n                .unwrap();\n\n            // Calculate the wait time\n            let duration_until = (start - now.naive_local()).to_std().unwrap();\n\n            tracing::info!(\"Waiting until midnight to start the loop\");\n\n            tokio::time::sleep(duration_until).await;\n\n            // Create an interval that ticks every 24 hours\n            let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(24 * 3600));\n\n            // We wait until midnight UTC to start the loop. Then, all subsequent ticks will be at midnight UTC.\n            // Midnight UTC is 7PM EST, so daily performance is updated then.\n            loop {\n                tracing::info!(\"Calculating day performance\");\n\n                // Get all accounts: all games, all users\n                let accounts = pool.get_all_accounts().await.unwrap_or_else(|e| {\n                    tracing::error!(\"Failed to fetch accounts: {}\", e);\n                    vec![] // Return an empty vector if fetching accounts fails.\n                });\n\n                // Iterate over all accounts and update the day performance.\n                for account in accounts {\n                    let email = account.id.clone();\n                    let game_id = account.game_id.clone();\n                    let account_value = account.value;\n                    let timestamp = chrono::Local::now().to_rfc3339();\n\n                    // Create a new day performance object wiht the current account value and timestamp\n                    let day_performance = models::DayPerformance {\n                        value: account_value,\n                        date: timestamp,\n                    };\n\n                    // Fetch the performance from the database\n                    let performance = pool\n                        .get_performance(&email.clone(), &game_id.clone())\n                        .await\n                        .unwrap_or_else(|e| {\n                            tracing::error!(\"Failed to fetch performance: {}\", e);\n                            Some(Performance::default())\n                        })\n                        .unwrap_or_default();\n\n                    // If the account_id is empty, create a new performance entry\n                    if performance.account_id.is_empty() {\n                        pool.create_performance(Performance {\n                            account_id: email.clone(),\n                            game_id: game_id.clone(),\n                            data: Vec::new(),\n                        })\n                        .await\n                        .unwrap();\n                    };\n\n                    // Add the day performance to the performance data\n                    if let Err(err) = pool\n                        .add_day_performance(&email, &game_id, day_performance)\n                        .await\n                    {\n                        tracing::error!(\"Failed to add day performance: {}: {}\", email, err);\n                    }\n\n                    performance_cache.invalidate(&email).await;\n                }\n\n                // tick in the end instead of the start so we don't miss any days\n                interval.tick().await;\n            }\n        }\n    });\n\n    // Build application with routes\n    let app = Router::new()\n        .route(\"/account\", get(accounts::get_account))\n        .route(\"/games/new\", post(accounts::create_game))\n        .route(\"/games\", get(accounts::get_games))\n        .route(\"/game\", delete(accounts::leave_game))\n        .route(\"/join\", post(accounts::join_game))\n        .route(\"/leaderboard\", get(accounts::get_leaderboard))\n        .route(\"/portfolio\", get(portfolio::get_portfolio))\n        .route(\"/transactions\", get(portfolio::get_transaction_history))\n        .route(\"/game_performance\", get(portfolio::get_game_performance))\n        .route(\"/pending\", get(portfolio::get_pending))\n        .route(\"/buy\", post(trading::buy_stock))\n        .route(\"/sell\", post(trading::sell_stock))\n        .route(\"/login\", get(auth::start_google_login))\n        .route(\"/logout\", get(auth::logout))\n        .route(\"/callback\", get(auth::handle_google_callback))\n        .route(\"/user\", get(auth::get_user_data))\n        // Database app state\n        .with_state(shared_state)\n        .layer(session_layer)\n        .layer(cors)\n        .layer(\n            TraceLayer::new_for_http()\n                .make_span_with(trace::DefaultMakeSpan::new().level(Level::INFO))\n                .on_response(trace::DefaultOnResponse::new().level(Level::INFO)),\n        );\n\n    // Run server on port 3000\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n\n    tracing::info!(\"Listening on: {}\", listener.local_addr().unwrap());\n    axum::serve(listener, app).await.unwrap();\n\n    // delete old sessions\n    deletion_task.await??;\n\n    Ok(())\n}\n\n/// Updates the account and portfolio for a given account and game.\n/// This function fetches the account and portfolio from the database, updates the stock prices and\n/// calculates the total portfolio value and today's change. It then updates the account and portfolio\n/// in the database.\nasync fn run_updates(pool: DatabasePool, email: &str, game_id: &str) -> Result<(), String> {\n    // Fetch holdings from the database\n    let holdings = match pool.get_holdings(email, game_id).await {\n        Ok(holdings) => holdings,\n        Err(e) => {\n            return Err(format!(\"Failed to fetch holdings: {}\", e));\n        }\n    };\n\n    let mut updated_holdings = Vec::new();\n    let mut total_portfolio_value = 0;\n    let mut total_today_change = 0;\n\n    // Update holdings with updated stock prices\n    for mut holding in holdings {\n        // Get stock quote\n        match yfinance::get_quote(holding.stock_symbol.clone()).await {\n            Ok(quote) => {\n                holding.current_price = quote.regular_market_price;\n                holding.total_value = quote.regular_market_price * holding.quantity;\n                holding.day_change = quote.day_change;\n                holding.day_change_percent = quote.day_change_percent;\n\n                holding.overall_change =\n                    holding.total_value - (holding.purchase_price * holding.quantity);\n\n                total_today_change += quote.day_change * holding.quantity;\n                total_portfolio_value += holding.total_value;\n            }\n            Err(e) => {\n                tracing::error!(\"Error fetching quote for {}: {}\", holding.stock_symbol, e);\n            }\n        };\n\n        updated_holdings.push(holding);\n\n        // Sleep for 100 milliseconds to avoid overwhelming the API\n        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n    }\n\n    let account = match match pool.get_account_with_game(email, game_id).await {\n        Ok(account) => account,\n        Err(e) => {\n            return Err(format!(\"Failed to fetch account details: {}\", e));\n        }\n    } {\n        Some(account) => account,\n        None => {\n            return Err(\"Account not found\".to_string());\n        }\n    };\n\n    // Update user portfolio and account in the database with updated values\n    pool.update_portfolio(email, game_id, updated_holdings)\n        .await\n        .map_err(|e| format!(\"Failed to update portfolio: {}\", e))?;\n\n    // Update the account value in the database\n    pool.update_account(\n        email,\n        game_id,\n        (account.cash + total_portfolio_value) as i64,\n        account.cash as i64,\n        total_today_change as i64,\n    )\n    .await\n    .map_err(|e| format!(\"Failed to update account: {}\", e))?;\n\n    Ok(())\n}\n```\n\n\nExplain this file concisely. \n# Main.rs Overview\n\nThis file is the entry point for a stock market simulation backend built with Rust and Axum. It handles:\n\n1. **Server Initialization**:\n   - Sets up logging based on command line arguments\n   - Configures session management with SQLite\n   - Establishes MongoDB connection\n   - Sets up CORS for frontend communication\n\n2. **Background Tasks**:\n   - Market updates (every 60 seconds when market is open)\n   - Trade execution processing (every 10 seconds)\n   - Daily performance calculations (at midnight UTC)\n\n3. **API Routes**:\n   - Account management (get account, create/join/leave games)\n   - Portfolio management (view holdings, transaction history)\n   - Trading operations (buy/sell stocks)\n   - Authentication (Google OAuth)\n\n4. **Core Functionality**:\n   - Real-time stock data retrieval (using Yahoo Finance and Finnhub)\n   - Trade execution with transaction management\n   - Portfolio valuation and performance tracking\n   - User session management\n\nThe application uses a shared state pattern with caching mechanisms to improve performance and implements proper error handling throughout the codebase.\nExplain the run_updatesn func\n# `run_updates` Function Explained\n\nThe `run_updates` function updates the account and portfolio data for a specific user in a specific game. Here's what it does:\n\n1. **Fetches Holdings**: Retrieves all stock holdings for the given account and game from the database.\n\n2. **Updates Each Holding**:\n   - Gets current stock price data from Yahoo Finance API\n   - Updates current price, total value, day change, and overall change for each holding\n   - Calculates the total portfolio value and today's total change\n   - Adds small delay between API calls to avoid rate limiting\n\n3. **Fetches Account Data**: Retrieves the user's account information including cash balance.\n\n4. **Updates Database**:\n   - Saves all updated holdings back to the database\n   - Updates the account with:\n     - New total value (cash + portfolio value)\n     - Current cash amount (unchanged)\n     - Today's change amount\n\nThe function handles errors at each step, returning detailed error messages if any operation fails. It's designed to be called periodically when the market is open to keep user portfolios up to date with current market prices.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":157}}},{"id":{"replica_id":0,"value":37},"start":31276,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":158}}},{"id":{"replica_id":0,"value":38},"start":32406,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":159}}},{"id":{"replica_id":0,"value":72},"start":32436,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":160}}},{"id":{"replica_id":0,"value":73},"start":33560,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":161}}}],"summary":"# Rust Trading Simulator Backend","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":2,"end":31244},"icon":"File","label":"stocksim-backend/src/main.rs","metadata":{"path":"stocksim-backend/src/main.rs"}}]}