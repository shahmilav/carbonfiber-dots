{"id":"85502360-cb02-4542-9b9b-29a7b28975b5","zed":"context","version":"0.4.0","text":"\n\n\n```go cacheapi/server/main.go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\n// CacheEntry stores the cached response body and the timestamp it was cached.\ntype CacheEntry struct {\n\tData      []byte\n\tTimestamp time.Time\n}\n\n// ConfigEntry maps UUIDs to registered URLs and TTLs.\ntype ConfigEntry struct {\n\tBaseURL string\n\tTTL     time.Duration\n}\n\nvar (\n\tcache       = make(map[string]CacheEntry)\n\tconfigStore = make(map[string]ConfigEntry)\n\tmutex       = &sync.Mutex{}\n)\n\n// RegisterHandler handles POST requests to register a URL + TTL\nfunc registerHandler(w http.ResponseWriter, r *http.Request) {\n\tenableCORSHeaders(w)\n\tif r.Method == http.MethodOptions {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\n\tif r.Method != http.MethodPost {\n\t\thttp.Error(w, \"Only POST allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tvar req struct {\n\t\tURL string `json:\"url\"`\n\t\tTTL int    `json:\"ttl\"` // seconds\n\t}\n\n\tbody, err := io.ReadAll(r.Body)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to read request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer r.Body.Close()\n\n\tif err := json.Unmarshal(body, &req); err != nil {\n\t\thttp.Error(w, \"Invalid JSON body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tif req.URL == \"\" || req.TTL <= 0 {\n\t\thttp.Error(w, \"Missing or invalid url/ttl\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Parse and validate URL\n\t_, err = url.ParseRequestURI(req.URL)\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid URL\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tid := uuid.New().String()\n\tentry := ConfigEntry{\n\t\tBaseURL: req.URL,\n\t\tTTL:     time.Duration(req.TTL) * time.Second,\n\t}\n\n\tmutex.Lock()\n\tconfigStore[id] = entry\n\tmutex.Unlock()\n\n\tresp := map[string]string{\"uuid\": id}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(resp)\n}\n\n// CacheHandler fetches/caches data based on UUID and dynamic query params\nfunc cacheHandler(w http.ResponseWriter, r *http.Request) {\n\tenableCORSHeaders(w)\n\tif r.Method == http.MethodOptions {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\n\tuuidKey := r.URL.Query().Get(\"uuid\")\n\tif uuidKey == \"\" {\n\t\thttp.Error(w, \"Missing uuid parameter\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tmutex.Lock()\n\tconfig, exists := configStore[uuidKey]\n\tmutex.Unlock()\n\n\tif !exists {\n\t\thttp.Error(w, \"UUID not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tbaseURL, err := url.Parse(config.BaseURL)\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid stored URL\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Combine query parameters\n\tfullParams := baseURL.Query()\n\tfor key, values := range r.URL.Query() {\n\t\tif key == \"uuid\" {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, val := range values {\n\t\t\tfullParams.Add(key, val)\n\t\t}\n\t}\n\tbaseURL.RawQuery = fullParams.Encode()\n\n\tcacheKey := baseURL.String()\n\n\tmutex.Lock()\n\tentry, found := cache[cacheKey]\n\tmutex.Unlock()\n\n\tif found && time.Since(entry.Timestamp) < config.TTL {\n\t\tlog.Printf(\"Cache hit for %s\", cacheKey)\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(entry.Data)\n\t\treturn\n\t}\n\n\tlog.Printf(\"Cache miss or expired for %s\", cacheKey)\n\tresp, err := http.Get(cacheKey)\n\tif err != nil {\n\t\thttp.Error(w, fmt.Sprintf(\"Fetch error: %v\", err), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\thttp.Error(w, fmt.Sprintf(\"Read error: %v\", err), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {\n\t\tw.WriteHeader(resp.StatusCode)\n\t\tw.Write(body)\n\t\treturn\n\t}\n\n\tmutex.Lock()\n\tcache[cacheKey] = CacheEntry{\n\t\tData:      body,\n\t\tTimestamp: time.Now(),\n\t}\n\tmutex.Unlock()\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Write(body)\n}\n\nfunc getAllJobs(w http.ResponseWriter, r *http.Request) {\n\tenableCORSHeaders(w)\n\tif r.Method == http.MethodOptions {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\n\tmutex.Lock()\n\tjobs := make([]string, 0, len(configStore))\n\tfor uuid := range configStore {\n\t\tjobs = append(jobs, uuid)\n\t}\n\tmutex.Unlock()\n\n\tresponse := struct {\n\t\tJobs []string `json:\"jobs\"`\n\t}{\n\t\tJobs: jobs,\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif err := json.NewEncoder(w).Encode(response); err != nil {\n\t\thttp.Error(w, \"Failed to encode response\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}\nfunc getJob(w http.ResponseWriter, r *http.Request) {\n\tenableCORSHeaders(w)\n\tif r.Method == http.MethodOptions {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\n\tuuid := r.URL.Query().Get(\"uuid\")\n\tif uuid == \"\" {\n\t\thttp.Error(w, \"Missing uuid parameter\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tmutex.Lock()\n\tconfig, exists := configStore[uuid]\n\tmutex.Unlock()\n\n\tif !exists {\n\t\thttp.Error(w, \"UUID not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tresponse := struct {\n\t\tUUID    string `json:\"uuid\"`\n\t\tBaseURL string `json:\"url\"`\n\t\tTTL     int    `json:\"ttl\"` // in seconds\n\t}{\n\t\tUUID:    uuid,\n\t\tBaseURL: config.BaseURL,\n\t\tTTL:     int(config.TTL.Seconds()),\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif err := json.NewEncoder(w).Encode(response); err != nil {\n\t\thttp.Error(w, \"Failed to encode response\", http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n\nfunc enableCORSHeaders(w http.ResponseWriter) {\n\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\tw.Header().Set(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/register\", registerHandler)\n\thttp.HandleFunc(\"/cache\", cacheHandler)\n\thttp.HandleFunc(\"/job\", getJob)\n\thttp.HandleFunc(\"/jobs\", getAllJobs)\n\n\tport := 8080\n\tlog.Printf(\"Cache proxy running on port %d\", port)\n\tlog.Fatal(http.ListenAndServe(fmt.Sprintf(\":%d\", port), nil))\n}\n```\n\nedit this code to have a name for a job too.\nI'll modify the code to add a \"name\" field for each registered job.\n\n<patch>\n<title>Add job name functionality to cacheapi server</title>\n\n<edit>\n<path>cacheapi/server/main.go</path>\n<operation>update</operation>\n<old_text>// ConfigEntry maps UUIDs to registered URLs and TTLs.\ntype ConfigEntry struct {\n\tBaseURL string\n\tTTL     time.Duration\n}</old_text>\n<new_text>// ConfigEntry maps UUIDs to registered jobs.\ntype ConfigEntry struct {\n\tName    string\n\tBaseURL string\n\tTTL     time.Duration\n}</new_text>\n</edit>\n\n<edit>\n<path>cacheapi/server/main.go</path>\n<operation>update</operation>\n<old_text>\tvar req struct {\n\t\tURL string `json:\"url\"`\n\t\tTTL int    `json:\"ttl\"` // seconds\n\t}</old_text>\n<new_text>\tvar req struct {\n\t\tURL  string `json:\"url\"`\n\t\tTTL  int    `json:\"ttl\"` // seconds\n\t\tName string `json:\"name\"`\n\t}</new_text>\n</edit>\n\n<edit>\n<path>cacheapi/server/main.go</path>\n<operation>update</operation>\n<old_text>\tif req.URL == \"\" || req.TTL <= 0 {\n\t\thttp.Error(w, \"Missing or invalid url/ttl\", http.StatusBadRequest)\n\t\treturn\n\t}</old_text>\n<new_text>\tif req.URL == \"\" || req.TTL <= 0 || req.Name == \"\" {\n\t\thttp.Error(w, \"Missing or invalid url/ttl/name\", http.StatusBadRequest)\n\t\treturn\n\t}</new_text>\n</edit>\n\n<edit>\n<path>cacheapi/server/main.go</path>\n<operation>update</operation>\n<old_text>\tentry := ConfigEntry{\n\t\tBaseURL: req.URL,\n\t\tTTL:     time.Duration(req.TTL) * time.Second,\n\t}</old_text>\n<new_text>\tentry := ConfigEntry{\n\t\tName:    req.Name,\n\t\tBaseURL: req.URL,\n\t\tTTL:     time.Duration(req.TTL) * time.Second,\n\t}</new_text>\n</edit>\n\n<edit>\n<path>cacheapi/server/main.go</path>\n<operation>update</operation>\n<old_text>func getAllJobs(w http.ResponseWriter, r *http.Request) {\n\tenableCORSHeaders(w)\n\tif r.Method == http.MethodOptions {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\n\tmutex.Lock()\n\tjobs := make([]string, 0, len(configStore))\n\tfor uuid := range configStore {\n\t\tjobs = append(jobs, uuid)\n\t}\n\tmutex.Unlock()\n\n\tresponse := struct {\n\t\tJobs []string `json:\"jobs\"`\n\t}{\n\t\tJobs: jobs,\n\t}</old_text>\n<new_text>func getAllJobs(w http.ResponseWriter, r *http.Request) {\n\tenableCORSHeaders(w)\n\tif r.Method == http.MethodOptions {\n\t\tw.WriteHeader(http.StatusOK)\n\t\treturn\n\t}\n\n\tmutex.Lock()\n\tjobs := make([]map[string]string, 0, len(configStore))\n\tfor uuid, config := range configStore {\n\t\tjobs = append(jobs, map[string]string{\n\t\t\t\"uuid\": uuid,\n\t\t\t\"name\": config.Name,\n\t\t})\n\t}\n\tmutex.Unlock()\n\n\tresponse := struct {\n\t\tJobs []map[string]string `json:\"jobs\"`\n\t}{\n\t\tJobs: jobs,\n\t}</new_text>\n</edit>\n\n<edit>\n<path>cacheapi/server/main.go</path>\n<operation>update</operation>\n<old_text>\tresponse := struct {\n\t\tUUID    string `json:\"uuid\"`\n\t\tBaseURL string `json:\"url\"`\n\t\tTTL     int    `json:\"ttl\"` // in seconds\n\t}{\n\t\tUUID:    uuid,\n\t\tBaseURL: config.BaseURL,\n\t\tTTL:     int(config.TTL.Seconds()),\n\t}</old_text>\n<new_text>\tresponse := struct {\n\t\tUUID    string `json:\"uuid\"`\n\t\tName    string `json:\"name\"`\n\t\tBaseURL string `json:\"url\"`\n\t\tTTL     int    `json:\"ttl\"` // in seconds\n\t}{\n\t\tUUID:    uuid,\n\t\tName:    config.Name,\n\t\tBaseURL: config.BaseURL,\n\t\tTTL:     int(config.TTL.Seconds()),\n\t}</new_text>\n</edit>\n\n</patch>\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":27}}},{"id":{"replica_id":0,"value":21},"start":5749,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":28}}},{"id":{"replica_id":0,"value":22},"start":8888,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":29}}}],"summary":"Adding job name to cache API","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":5703},"icon":"File","label":"cacheapi/server/main.go","metadata":{"path":"cacheapi/server/main.go"}}],"thought_process_output_sections":[]}